/*
 * generated by Xtext 2.10.0
 */
package fr.i3s.gciatto.snn2uta.generator

import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.AccumulationPeriodParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Event
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.FloatParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.InputNeuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.IntParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.LeakageFactorParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Network
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Neuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.NumericParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.OutputNeuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Pause
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.RefractoryPeriodParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Spike
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Synapsis
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.ThresholdParam
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import fr.i3s.gciatto.utils.Dot
import java.io.IOException

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
package class NetworkDescriptionLanguageToGraphVizGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val ctx = if (context instanceof GeneratorContext) context as GeneratorContext else new GeneratorContext(context)
		val code = resource.allContents.filter(typeof(Network)).map[generateNetwork(it, ctx)].head

		if (!ctx.cancelIndicator.canceled) {
			fsa.generateFile('''«ctx.name».gv''', code)
			
			try {
				Dot.invokeSync(fsa.readBinaryFile('''«ctx.name».gv'''), [
					fsa.generateFile('''«ctx.name».gv.png''', it)
				])
			} catch(IOException e) {
				e.printStackTrace
			}
		}

	}

	def CharSequence generateNetwork(Network net, GeneratorContext ctx) {
		ctx.name = net.name

		'''
		digraph «ctx.name» {
		  rankdir=LR;
		  
			«FOR n : net.neurons SEPARATOR '\n'»
				«n.generateNeuron(ctx)»;
			«ENDFOR»
			
			«FOR s : net.synapses SEPARATOR '\n'»
				«s.generateSynapsis(ctx)»;
			«ENDFOR»
		}'''
	}
	
	def CharSequence generateSynapsis(Synapsis s, GeneratorContext ctx) {
		if (s.weight == null)
			s.weight = Defaults.SYNAPSIS_WEIGHT
			
		'''«s.source.name» -> «s.destination.name» [label=«s.weight»«IF s.weight < 0» arrowhead=odot«ENDIF»]'''
	}

	def CharSequence generateDiscrtized(double x, GeneratorContext ctx) {
		Math.round(x * ctx.granularity).toString
	}

	def dispatch CharSequence generateNeuron(InputNeuron in, GeneratorContext ctx) {
		//'''«in.name» [shape=box label="«in.name»\n«in.events.generateEvents(in.repeat, ctx)»"]'''
		'''«in.name» [shape=box label="«in.name»"]'''
	}

	def dispatch CharSequence generateNeuron(Neuron n, GeneratorContext ctx) {
		var params = n.args

		val refractory = params.filter(RefractoryPeriodParam).valueOrDefault(Defaults.REFRACTORY_PERIOD).intValue
		val accumulation = params.filter(AccumulationPeriodParam).valueOrDefault(Defaults.ACCUMULATION_PERIOD).intValue
		val threshold = params.filter(ThresholdParam).valueOrDefault(Defaults.THRESHOLD).doubleValue
		val leakage = {
			val temp = params.filter(LeakageFactorParam).head
			if(temp == null) Defaults.LEAKAGE_FACTOR else #[temp.value.num, temp.value.den]
		}
		
		val tmp = #[
			'''T: «accumulation»''',
			'''τ: «refractory»''',
			'''θ: «threshold»''',
			'''r: «leakage.get(0) as double / leakage.get(1)»'''
		]
		
		'''«n.name» [shape=«IF n instanceof OutputNeuron»doublecircle«ELSE»circle«ENDIF» label="«n.name»\n\n«FOR l : tmp SEPARATOR "\\n"»«l»«ENDFOR»"]'''
	}

	static def <T, N extends Number> Number valueOrDefault(Iterable<? extends NumericParam> xs, N alt) {
		if (xs.empty) {
			alt
		} else {
			var x = xs.head
			if (IntParam.isAssignableFrom(x.class))
				return (x as IntParam).value
			else if (FloatParam.isAssignableFrom(x.class))
				return (x as FloatParam).value
			else
				throw new IllegalStateException("Unhandled case")
		}
	}

	def CharSequence generateEvents(List<Event> lst, boolean repeat, GeneratorContext ctx) {
		'''«FOR e : lst»«e.generateEvent(ctx)»«ENDFOR»«IF repeat»⮨«ELSE»⮽«ENDIF»'''
	}

	def dispatch generateEvent(Event e, GeneratorContext ctx) {
		throw new IllegalStateException("This function should never be invoked")
	}
	
	def dispatch generateEvent(Spike e, GeneratorContext ctx) {
		"*"
	}
	
	def dispatch generateEvent(Pause e, GeneratorContext ctx) {
		'''«FOR i : 0 ..< e.duration»_«ENDFOR»'''
	}
}