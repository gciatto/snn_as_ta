/*
 * generated by Xtext 2.10.0
 */
package fr.i3s.gciatto.snn2uta.generator

import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.AccumulationPeriodParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.DiscretizationGranularityParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Event
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.FloatParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.InputNeuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.IntParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.LeakageFactorParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Network
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Neuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.NumericParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.OutputNeuron
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Pause
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.RefractoryPeriodParam
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Spike
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.Synapsis
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.ThresholdParam
import java.util.LinkedList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.common.collect.Iterables
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.TimeUnit
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.TimeOffset
import fr.i3s.gciatto.snn2uta.networkDescriptionLanguage.NetworkDescriptionLanguageFactory

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
package class NetworkDescriptionLanguageToUppaalGenerator extends AbstractGenerator {

	private static class Location {
		static val x0 = 0
		static val y0 = 0
		static val dx = Transition.length + 25
		static val dy = 0

		static val down = 17
		static val up = -34

		static def x(int i) {
			return x0 + i * dx
		}

		static def y(int i) {
			return y0 + i * dy
		}
	}

	private static class Transition {
		static val length = 200
		static val margin = 100

		static val up = -17
		static val down = 1
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val ctx = if(context instanceof GeneratorContext) context as GeneratorContext else new GeneratorContext(context)
		val code = resource.allContents.filter(typeof(Network)).map[generateNetwork(it, ctx)].head

		if (!ctx.cancelIndicator.canceled)
			fsa.generateFile('''«ctx.name».xml''', code)

	}

	def CharSequence generateNetwork(Network net, GeneratorContext ctx) {
		ctx.name = net.name

		'''
			<?xml version="1.0" encoding="utf-8"?>
			<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
			<nta>
				<declaration>
			«net.generateGlobalDeclarations(ctx)»
				</declaration>
				«FOR n : net.neurons SEPARATOR '\n'»
					«n.generateNeuron(ctx)»
				«ENDFOR»
				«generateOutputTemplate(ctx)»
				<system>
			«net.generateSystem(ctx)»
				</system>
			</nta>
		'''
	}

	def CharSequence generateOutputTemplate(GeneratorContext ctx) {
		val Wid = ctx.nextId
		val Oid = ctx.nextId

		'''
			<template>
					<name>Output</name>
					<parameter>broadcast chan &amp;y</parameter>
					<declaration>
						clock sinceLastOutput;
						bool even = true;
					</declaration>
					<location id="«Oid»" x="-213" y="-255">
						<name x="-223" y="-289">O</name>
						<committed/>
					</location>
					<location id="«Wid»" x="-476" y="-255">
						<name x="-486" y="-289">W</name>
					</location>
					<init ref="«Wid»"/>
					<transition>
						<source ref="«Oid»"/>
						<target ref="«Wid»"/>
						<label kind="assignment" x="-399" y="-204">sinceLastOutput = 0,
						even = not(even)</label>
						<nail x="-349" y="-204"/>
					</transition>
					<transition>
						<source ref="«Wid»"/>
						<target ref="«Oid»"/>
						<label kind="synchronisation" x="-349" y="-323">y?</label>
						<nail x="-340" y="-306"/>
					</transition>
				</template>
		'''
	}

	def CharSequence generateGlobalDeclarations(Network net, GeneratorContext ctx) {
		val granularity = net.globals.filter(DiscretizationGranularityParam).head
		ctx.granularity = (granularity?.value) ?: Defaults.REAL_GRANULARITY

		val timeUnit = net.globals.filter(TimeUnit).head
		ctx.timeUnit = (timeUnit?.value) ?: Defaults.TIME_UNIT

		val timeOffset = net.globals.filter(TimeOffset).head
		ctx.timeOffset = (timeOffset?.value) ?: Defaults.TIME_OFFSET

		ctx.putSynapses(net.synapses)

		'''
			«IF ctx.timeUnit != Defaults.TIME_UNIT»
				// Time Unit: «ctx.timeUnit»
			«ENDIF»«IF ctx.timeOffset != Defaults.TIME_OFFSET»
			// Time Offset: «ctx.timeOffset»«ENDIF»
			
			
			typedef struct {
			    int num;
			    int den;
			} ratio_t;
			
			const int R = «ctx.granularity»;
			typedef int[-R, R] weight_t;
			
			«FOR n : ctx.actuallyUsedNeurons SEPARATOR "\n\n"»
				// Neuron '«n.name»' //////////////////////////////////
				const int M_«n.name» = «ctx.countInputs(n)»;
				weight_t w_«n.name»[M_«n.name»] = { «FOR i : ctx.getInputSynapses(n) SEPARATOR ", "»«i.generateDiscrtizedWeight(ctx)»«ENDFOR» };
				broadcast chan y_«n.name»;
			«ENDFOR»
			
			«FOR in : net.neurons.filter(InputNeuron) SEPARATOR "\n\n"»
				// Input '«in.name»' //////////////////////////////////
				broadcast chan y_«in.name»;
			«ENDFOR»
		'''
	}

	def CharSequence generateDiscrtizedWeight(Synapsis s, GeneratorContext ctx) {
		if (s.weight == null)
			s.weight = Defaults.SYNAPSIS_WEIGHT

		s.weight.generateDiscrtized(ctx)
	}

	def CharSequence generateDiscrtized(double x, GeneratorContext ctx) {
		Math.round(x * ctx.granularity).toString
	}

	def CharSequence generateSystem(Network net, GeneratorContext ctx) {
		var temp = new LinkedList<String>()

		'''
			// Input producers
			«FOR in : net.neurons.filter(InputNeuron) SEPARATOR "\n"»
				«{ val t = in.name; temp.add(t); t }» = «generateTemplateName(in)»(y_«in.name»);
			«ENDFOR»
			
			// Neurons
			«FOR n : net.neurons.filter[!InputNeuron.isAssignableFrom(it.class)] SEPARATOR "\n"»
				«{ val t = n.name; temp.add(t); t }» = «generateTemplateName(n)»(«FOR i : ctx.getInputSynapses(n).map[it.source] SEPARATOR ", "»y_«i.name»«ENDFOR», w_«n.name», y_«n.name»);
			«ENDFOR»
			
			// Output consumers
			«FOR n : net.neurons.filter(OutputNeuron) SEPARATOR "\n"»
				«{ val t = '''O_«n.name»'''; temp.add(t); t }» = Output(y_«n.name»);
			«ENDFOR»
			
			system «FOR n : temp SEPARATOR ", "»«n»«ENDFOR»;
		'''
	}

	private def CharSequence generateTemplateName(Neuron n) {
		'''«IF InputNeuron.isAssignableFrom(n.class)»Input_«ELSE»Neuron_«ENDIF»«n.name»'''
	}

	def dispatch CharSequence generateNeuron(InputNeuron in, GeneratorContext ctx) {
		if (in.any) {
			generateInputNeuronAny(in, ctx)
		} else if (in.rate) {
			generateInputNeuronRate(in, ctx)
		} else {
			generateInputNeuronInputSeq(in, ctx)
		}
	}

	def CharSequence generateInputNeuronRate(InputNeuron in, GeneratorContext ctx) {
		var T = (in?.period ?: Defaults.FIXED_RATE_PERIOD) * ctx.timeUnit
		var D = (in?.initialDelay ?: Defaults.INITIAL_DELAY) * ctx.timeUnit
		val Bid = ctx.nextId
		val Sid = ctx.nextId
		val Wid = ctx.nextId

		'''
			<template>
				<name>«generateTemplateName(in)»</name>
				<parameter>broadcast chan &amp;x</parameter>
				<declaration>
			clock t = 0.0;
						
			const int D = «D»;
			
			const int T = «T»;
			
			</declaration>
				<location id="«Sid»" x="221" y="-127">
					<name x="211" y="-161">S</name>
					<label kind="invariant" x="211" y="-110">t &lt;= T</label>
					<label kind="exponentialrate" x="211" y="-93">1</label>
				</location>
				<location id="«Wid»" x="-144" y="-127">
					<name x="-154" y="-161">W</name>
					<label kind="invariant" x="-154" y="-110">t &lt; T</label>
					<label kind="exponentialrate" x="-154" y="-93">1</label>
				</location>
				<location id="«Bid»" x="-467" y="-127">
					<name x="-477" y="-161">B</name>
					<label kind="invariant" x="-477" y="-110">t &lt;= D</label>
					<label kind="exponentialrate" x="-477" y="-93">1</label>
				</location>
				<init ref="«Bid»"/>
				<transition>
					<source ref="«Sid»"/>
					<target ref="«Wid»"/>
					<label kind="guard" x="25" y="-59">t == T</label>
					<label kind="assignment" x="25" y="-85">t = 0</label>
					<nail x="42" y="-59"/>
				</transition>
				<transition>
					<source ref="«Wid»"/>
					<target ref="«Sid»"/>
					<label kind="guard" x="-8" y="-212">t &gt; 0 &amp;&amp; t &lt; T</label>
					<label kind="synchronisation" x="34" y="-187">x!</label>
					<nail x="34" y="-195"/>
				</transition>
				<transition>
					<source ref="«Bid»"/>
					<target ref="«Wid»"/>
					<label kind="guard" x="-374" y="-144">t == D«IF ctx.timeOffset > 0» + «ctx.timeOffset»«ENDIF»</label>
					<label kind="assignment" x="-365" y="-127">t = 0</label>
				</transition>
			</template>
		'''
	}

	def CharSequence generateInputNeuronInputSeq(InputNeuron in, GeneratorContext ctx) {
		var events = Iterables.concat(in.finite, in.periodic);

		if (ctx.timeOffset > 0) {
			val p = NetworkDescriptionLanguageFactory.eINSTANCE.createPause();
			p.name = 'offset'
			p.duration = ctx.timeOffset
			in.finite.add(0, p)
		}

		val res = '''
			<template>
			<name>«generateTemplateName(in)»</name>
			<parameter>broadcast chan &amp;x</parameter>
			<declaration>
			clock t;
			bool spiking = false;
			
			«FOR e : events.indexed.filter[it.value instanceof Pause].filter[it.value.name != 'offset'] SEPARATOR "\n"»
				const int T«e.key» = «((e.value as Pause).duration ?: Defaults.PAUSE_DURATION) * ctx.timeUnit»;
			«ENDFOR»
			
			</declaration>
			
			«generateEvents(in.finite, in.periodic, ctx)»
			</template>
		'''

		if (ctx.timeOffset > 0) {
			in.finite.remove(0)
		}

		return res
	}

	def CharSequence generateInputNeuronAny(InputNeuron in, GeneratorContext ctx) {
		var Tmin = (in?.minDelay ?: Defaults.ANY_MIN_DELAY) * ctx.timeUnit
		var D = (in?.initialDelay ?: Defaults.INITIAL_DELAY) * ctx.timeUnit
		val Bid = ctx.nextId
		val Sid = ctx.nextId
		val Wid = ctx.nextId

		return '''
			<template>
					<name>«generateTemplateName(in)»</name>
					<parameter>broadcast chan &amp;x</parameter>
					<declaration>
			clock t;
			
			bool spiking = false;
							
			const int Tmin = «Tmin»;
			const int D = «D»;
			    </declaration>
					<location id="«Bid»" x="527" y="-178">
						<name x="517" y="-212">B</name>
						<label kind="exponentialrate" x="517" y="-144">1</label>
					</location>
					<location id="«Sid»" x="314" y="-178">
						<name x="304" y="-212">S</name>
						<committed/>
					</location>
					<location id="«Wid»" x="42" y="-178">
						<name x="32" y="-212">W</name>
						<label kind="exponentialrate" x="25" y="-161">1</label>
					</location>
					<init ref="«Bid»"/>
					<transition>
						<source ref="«Bid»"/>
						<target ref="«Sid»"/>
						<label kind="guard" x="425" y="-195">t &gt;= D«IF ctx.timeOffset > 0» + «ctx.timeOffset»«ENDIF»</label>
						<label kind="synchronisation" x="382" y="-195">x!</label>
						<label kind="assignment" x="357" y="-178">t = 0, spiking = true</label>
					</transition>
					<transition>
						<source ref="«Sid»"/>
						<target ref="«Wid»"/>
						<label kind="assignment" x="135" y="-136">spiking = false</label>
						<nail x="186" y="-136"/>
					</transition>
					<transition>
						<source ref="«Wid»"/>
						<target ref="«Sid»"/>
						<label kind="guard" x="152" y="-280">t &gt; Tmin</label>
						<label kind="synchronisation" x="152" y="-263">x!</label>
						<label kind="assignment" x="152" y="-246">t = 0, spiking = true</label>
						<nail x="169" y="-221"/>
					</transition>
				</template>
		'''
	}

	def dispatch CharSequence generateNeuron(OutputNeuron on, GeneratorContext ctx) {
		generateInnerNeuron(on, ctx)
	}

	def dispatch CharSequence generateNeuron(Neuron n, GeneratorContext ctx) {
		generateInnerNeuron(n, ctx)
	}

	private def CharSequence generateInnerNeuron(Neuron n, GeneratorContext ctx) {
		var params = n.args

		val refractory = (params.filter(RefractoryPeriodParam).valueOrDefault(Defaults.REFRACTORY_PERIOD).intValue) *
			ctx.timeUnit
		val accumulation = (params.filter(AccumulationPeriodParam).valueOrDefault(Defaults.ACCUMULATION_PERIOD).
			intValue) * ctx.timeUnit
		val threshold = params.filter(ThresholdParam).valueOrDefault(Defaults.THRESHOLD).doubleValue
		val leakage = {
			val temp = params.filter(LeakageFactorParam).head
			if(temp == null) Defaults.LEAKAGE_FACTOR else #[temp.value.num, temp.value.den]
		}

		val Aid = ctx.nextId
		val Did = ctx.nextId
		val Wid = ctx.nextId

		val m = ctx.countInputs(n)

		'''
			<template>
				<name>«generateTemplateName(n)»</name>
				<parameter>«FOR i : 0 ..< m SEPARATOR ", "»broadcast chan &amp;x«i»«ENDFOR», weight_t &amp;w[M_«n.name»], broadcast chan &amp;y</parameter>
				<declaration>
			clock t;
			const int T = «accumulation»;
			const int tau = «refractory»;
			const int theta = «threshold.generateDiscrtized(ctx)»;
			ratio_t lambda = { «leakage.get(0)», «leakage.get(1)» };
			
			int spikesInCurrentPeriod = 0;
			int consecutivesInputs = 0;
			int consecutivesOutputs = 0;
			
			int a = 0;
			int p = 0;
			
			void accumulate(int i) { 
			  a += w[i]; 
			}
			
			void updatePotential() { 
			  p = (a * lambda.den + p * lambda.num) / lambda.den;
			}
			
			void onInput(int i) {
			  accumulate(i);
			  spikesInCurrentPeriod++;
			}
			
			void onAccumulationEnd() {
			  updatePotential();
			
			  if (spikesInCurrentPeriod &gt; 0) { 
			    consecutivesInputs++; 
			  } else { 
			    consecutivesInputs = 0; 
			  }
			}
			
			void onAccumulationBegin(bool hasEmitted) {
			  t = 0;
			  a = 0;
			
			  spikesInCurrentPeriod = 0;
			
			  if (hasEmitted) {
			    consecutivesOutputs++;
			  } else {
			    consecutivesOutputs = 0;
			  }
			}
			
			void onRefractoryEnd() {
			  
			}
			
			void onRefractoryBegin() {
			  p = 0;
			  t = 0;
			}
				</declaration>
				<location id="«Wid»" x="-331" y="-1495">
					<name x="-341" y="-1529">W</name>
					<label kind="invariant" x="-305" y="-1504">t &lt;= tau</label>
				</location>
				<location id="«Did»" x="-331" y="-1232">
					<name x="-322" y="-1215">D</name>
					<committed/>
				</location>
				<location id="«Aid»" x="-722" y="-1232">
					<name x="-773" y="-1283">A</name>
					<label kind="invariant" x="-781" y="-1266">t &lt;= T</label>
				</location>
				<init ref="«Aid»"/>
				<transition>
					<source ref="«Wid»"/>
					<target ref="«Aid»"/>
					<label kind="guard" x="-696" y="-1487">t == tau</label>
					<label kind="assignment" x="-696" y="-1470">onRefractoryEnd(),
			onAccumulationBegin(true)</label>
						<nail x="-722" y="-1495"/>
				</transition>
				<transition>
					<source ref="«Did»"/>
					<target ref="«Wid»"/>
					<label kind="guard" x="-322" y="-1393">p &gt;= theta</label>
					<label kind="synchronisation" x="-322" y="-1376">y!</label>
					<label kind="assignment" x="-322" y="-1359">onRefractoryBegin()</label>
				</transition>
				<transition>
					<source ref="«Did»"/>
					<target ref="«Aid»"/>
					<label kind="guard" x="-552" y="-1334">p &lt; theta</label>
					<label kind="assignment" x="-594" y="-1351">onAccumulationBegin(false)</label>
					<nail x="-518" y="-1317"/>
				</transition>
				<transition>
					<source ref="«Aid»"/>
					<target ref="«Did»"/>
					<label kind="guard" x="-552" y="-1249">t == T</label>
					<label kind="assignment" x="-586" y="-1232">onAccumulationEnd()</label>
				</transition>
				«FOR i : 0 ..< m SEPARATOR "\n"»
					<transition>
						<source ref="«Aid»"/>
						<target ref="«Aid»"/>
						<label kind="guard" x="«-790 + i * 120»" y="-1147">t &lt;= T</label>
						<label kind="synchronisation" x="«-790 + i * 120»" y="-1130">x«i»?</label>
						<label kind="assignment" x="«-790 + i * 120»" y="-1113">onInput(«i»)</label>
						<nail x="-671" y="-1172"/>
						<nail x="-765" y="-1173"/>
					</transition>
				«ENDFOR»
			</template>
		'''
	}

	static def <T, N extends Number> Number valueOrDefault(Iterable<? extends NumericParam> xs, N alt) {
		if (xs.empty) {
			alt
		} else {
			var x = xs.head
			if (IntParam.isAssignableFrom(x.class))
				return (x as IntParam).value
			else if (FloatParam.isAssignableFrom(x.class))
				return (x as FloatParam).value
			else
				throw new IllegalStateException("Unhandled case")
		}
	}

	def CharSequence generateEvents(List<Event> finite, List<Event> periodic, GeneratorContext ctx) {
		if (finite.size + periodic.size == 0) {
			generateEventsEnding(0, false, 0, ctx)
		} else {
			val Iterable<Event> lst = Iterables.concat(finite, periodic)
			generateEvents(lst.head, lst.tail, 0, periodic.size > 0, finite.size, ctx)
		}
	}

	private def dispatch CharSequence generateEvents(Event head, Iterable<Event> tail, int index, boolean repeat,
		int repeatFromIndex, GeneratorContext ctx) {
		throw new IllegalStateException("This function should never be invoked")
	}

	val tagRepeatFromId = "repeatFromId"

	private def dispatch CharSequence generateEvents(Spike head, Iterable<Event> tail, int index, boolean repeat,
		int repeatFromIndex, GeneratorContext ctx) {
		val x = Location.x(index)
		val y = Location.y(index)

		var currId = ctx.nextId

		if (repeat && index == repeatFromIndex) {
			ctx.storeId(tagRepeatFromId)
		}

		'''
			<location id="id«currId»" x="«x»" y="«y»">
				<name x="«x»" y="«y + Location.down»">S«index»</name>
				<urgent/>
			</location>
			«IF tail.empty»
				«generateEventsEnding(index + 1, repeat, repeatFromIndex, ctx)»
			«ELSE»
				«generateEvents(tail.head, tail.tail, index + 1, repeat, repeatFromIndex, ctx)»
			«ENDIF»
			<transition>
				<source ref="id«currId»"/>
				<target ref="id«currId + 1»"/>
				<label kind="synchronisation" x="«(x + Location.dx) / 2»" y="«y + Transition.up»">x!</label>
				<label kind="assignment" x="«(x + Location.dx) / 2»" y="«y + Transition.down»">spiking = false</label>
			</transition>
		'''
	}

	private def dispatch CharSequence generateEvents(Pause head, Iterable<Event> tail, int index, boolean repeat,
		int repeatFromIndex, GeneratorContext ctx) {
		val x = Location.x(index)
		val y = Location.y(index)

		var currId = ctx.nextId

		if (repeat && index == repeatFromIndex) {
			ctx.storeId(tagRepeatFromId)
		}

		if (head.duration == null)
			head.duration = Defaults.PAUSE_DURATION

		val T = '''«IF head.name == "offset"»«ctx.timeOffset»«ELSE»T«index»«ENDIF»'''

		'''
			<location id="id«currId»" x="«x»" y="«y»">
				<name x="«x»" y="«y + Location.down»">P«index»</name>
				<label kind="invariant" x="«x»" y="«y + Location.up»">t &lt;= «T»</label>
			</location>
			«IF tail.empty»
				«generateEventsEnding(index + 1, repeat, repeatFromIndex, ctx)»
			«ELSE»
				«generateEvents(tail.head, tail.tail, index + 1, repeat, repeatFromIndex, ctx)»
			«ENDIF»
			<transition>
				<source ref="id«currId»"/>
				<target ref="id«currId + 1»"/>
				<label kind="guard" x="«(x + Location.dx) / 2»" y="«y + Transition.up»">t == «T»</label>
				<label kind="assignment" x="«(x + Location.dx) / 2»" y="«y + Transition.down»">t = 0,
				spiking = true</label>
			</transition>
		'''
	}

	private def CharSequence generateEventsEnding(int index, boolean repeat, int repeatFromIndex,
		GeneratorContext ctx) {
		val x = Location.x(index)
		val y = Location.y(index)

		val x_r = x + Transition.margin
		val x_l = Location.x(repeatFromIndex) - Transition.margin
		val y_u = y - Transition.margin

		val currId = ctx.nextId
		var firstId = currId - index;
		val repeatFromId = ctx.retrieveId(tagRepeatFromId)

		'''
			<location id="id«currId»" x="«x»" y="«y»">
				<name x="«x»" y="«y + Location.down»">«IF repeat»R«ELSE»E«ENDIF»</name>
				«IF repeat»
					<committed/>
				«ENDIF»
			</location>
			<init ref="id«firstId»"/>
			«IF repeat»
				<transition>
					<source ref="id«currId»"/>
					<target ref="id«repeatFromId»"/>
					<label kind="assignment" x="«(x_r + x_l) / 2»" y="«y_u - Location.down»">t = 0</label>
					<nail x="«x_r»" y="«y»"/>
					<nail x="«x_r»" y="«y_u»"/>
					<nail x="«x_l»" y="«y_u»"/>
				</transition>
			«ENDIF»
		'''
	}
}
